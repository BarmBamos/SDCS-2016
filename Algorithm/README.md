# 算法设计与分析

---

## 复杂性分析

### 函数渐进的界　

1. 若存在正数c和n<sub>0</sub>使得对一切n >= n<sub>0</sub>有0 <= f(n) <= cg(n)成立，则称f(n)的渐进的上界是g(n)，记做f(n) = O(g(n))。

2. 若存在正数c和n<sub>0</sub>使得对一切n >= n<sub>0</sub>有0 <= cg(n) <= f(n)成立，则称f(n)的渐进的下界是g(n)，记做f(n) = Ω(g(n))。

3. 若f(n) = O(g(n))且f(n) = Ω(g(n))，则称f(n) = Θ(g(n))，称为紧渐进界。


---

## 分治策略

### 基本概念

简而言之就是把一个复杂问题分成两个或者多个相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，最终原问题的解就是各个子问题的合并。常见的运用如快速排序或归并排序等。

任何一个问题的计算时间都与其规模有关，问题规模约小越容易求解，比如归并排序在n=1时，不需要任何计算，只要做一次比较就可以排序好。

### 基本思想及策略

#### 设计思想

将一个难以解决的大问题，分割成规模较小的相同问题，以便各个解决。

#### 分治思路

对于一个规模为n的问题，如果能够直接求解则直接得到结果，否则将该问题分解成k个具有相同问题形式但规模较小的问题，这些子问题相互独立。求解这些子问题使用递归的方式，最后将各个问题的解合并得到原问题的解。

### 分治适用情况

1. 问题缩小到一定规模可以容易地解决。

2. 该问题可以分解为若干规模较小的相同问题，即该问题具有最优子结构性质。

3. 利用该问题分解出的子问题的解可以合并成该问题的解。

4. 各个子问题是相互独立的。

其中第一条通常很容易达到，第二条特征反映了递归思想。第三条是分治算法的关键，如果不满足这条特征可以考虑贪心或动态规划法。第四条涉及分治的效率，如果各子问题不独立会重复做很多不必要的工作，这种情况通常考虑动态规划算法。

### 分治基本步骤

分治在每一层递归上都有三个步骤：

1. 分解：将远问题分解成若干规模较小，相互独立与原问题西安鬼头鬼脑的子问题。

2. 解决：若子问题可以直接解决则解决，否则递归调用分拆成更小的子问题。

3. 合并：将各个子问题和并为原问题的解。

### 分治的复杂性分析

分治将规模为n的问题分成k个规模为n/k的子问题去解决，假设原问题分解为k个子问题以及用merge将k个子问题的解和并为远问题的解需要f(n)个单位时间，T(n)表示该分治法规模为n所耗费的计算时间。

- T(n) = k•T(n/k) + f(n)

- T(1) = c

这里通过求解递归式得到算法的复杂度，这里用归并算法为例。

- T(n) = 2•T(n/2) + n - 1

- T(1) = 0

设n = 2<sup>k</sup>，则原式子可化为：

T(2<sup>k</sup>) = 2•T(2<sup>k-1</sup>) + 2<sup>k</sup> - 1
    
= 2•[2•T(2<sup>k-2</sup>) + 2<sup>k-1</sup> - 1] + 2<sup>k</sup> - 1

= 2<sup>2</sup>T(2<sup>k-2</sup>) + (2<sup>k</sup> - 2) + (2<sup>k</sup> - 1)

= ……

= 2<sup>k</sup>•T(2<sup>k-k</sup>) + (2<sup>k</sup> - 2<sup>k-1</sup>) +……+(2<sup>k</sup> - 2<sup>0</sup>)

因为T(1) = 0，所以上式可化简为：

T(n) = T(2<sup>k</sup>)

= k•2<sup>k</sup> - (2<sup>0</sup> + 2<sup>1</sup> +……+2<sup>k-1</sup>)

= k•2<sup>k</sup> - (2<sup>k</sup> - 1)

因为n = 2<sup>k</sup>，所以k = log<sub>2</sub>n，带入可得：

T(n) = n•log<sub>2</sub>n - n + 1

### 分治法经典应用

1. 二分查找

2. 大整数乘法

3. Strassen矩阵乘法

4. 棋盘覆盖

5. 归并排序

6. 快速排序

7. 汉诺塔

8. 最接近点问题

### 思维过程

类似数学归纳法，先找到小规模时候求解方法，再考虑规模增大时求解方法，找到递归函数式之后设计递归程序即可。

---

## 动态规划

### 基本概念

每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生的，所以这种多借点优化决策解问题的过程就称为动态规划。

### 基本思路及策略

基本思想和分治法类似，将待求解问题分为若干子问题，按顺序求解子阶段，前一子阶段的解为后一阶段的决策提供了有用信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它的局部解。依次解决各个子问题，最后一个问题的解就是初始问题的解。

采用动态规划解决的问题依赖于之前的状态，所以通常有重叠子问题这个特点，为了减少计算，对每一个问题只求解一次，将其不同的状态保存在一个二维数组中。也就是说动态规划之所以能够快速解决含有重叠子结构问题最主要的原因是已经通过数组记录下了之前的状态，而不需要每次重新计算。

相比于分治法，动态规划最大的区别在于：适用于动态规划求解的问题，其各个子问题并不是完全独立的，下一阶段的状态需要考虑前一阶段的值。而分治法被划分出的各个子问题间却是相互独立的。不存在依赖关系。

### 适用情况

通常使用动态规划时，问题具有如下性质：

1. 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，则该问题具有最优子结构，即满足最优化原理。

2. 无后效性：即某个状态一旦确定，就不受这个状态以后的决策影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

3. 有重叠子问题：即子问题间不是独立的，一个子问题在下一阶段的决策中被多次用到。（非必要条件，但不具有此性质，动态规划相比于其他算法不具有优势）

### 基本步骤

动态规划所处理的是一个多阶段决策问题，由初始状态开始，经过中间状态达到最终的结束状态，形成一个决策序列。

一般需要经历以下步骤：

1. 划分阶段：按照问题时间或空间特征，把问题分为若干阶段。在划分阶段，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就可能无解。

2. 确定状态和状态变量：将问题发展到各个阶段所处的各种客观情况用不同状态表示出来。当然，状态的选择要满足无后效性。

3. 确定决策并写状态转移方程：因为决策和状态转移有天然联系，状态转移就是根据上衣阶段的状态和决策导出本阶段的状态。所以如果决定了决策，状态转移方程也就可写出。但事实上实际上是反过来做，根据相邻的两个状态之间的关系来确定决策的方法和状态转移方程。

4. 寻找边界条件：给出状态转移方程是一个递推式，需要一个递推中止条件或边界条件。

实际应用中可以按照以下简化步骤设计：

1. 分析最优解性质，刻画结构特征。

2. 递归的定义最优解。

3. 自底向上或自顶向下的记忆化方式计算出最优解。

4. 根据最优值得到的信息，构造问题最优解。

### 算法实现说明

使用动态规划解决问题，最重要的就是动态规划三要素了：

1. 问题的阶段。

2. 每个阶段的状态。

3. 从前一个状态转化到后一个状态的递推关系。

递推关系往往是从小问题到大问题的转化，所以动态规划问题通常可以通过递推关系式来实现，不过相比于递归，递推可以保存子问题的解来减少重复计算量。

整个求解过程可以用最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题的状态，表格需要填写数据对应此问题在某个阶段某个状态下的最优值，填表过程就是根据递推关系从第一行第一列开始依次填表，最后通过简单读表即可得到最优解。

---

## 贪心算法

### 基本概念

在对问题求解时，总是做出在当前看来最好的选择，也就是说，并不从整体最优来考虑问题，所做出的仅是某种意义上的局部最优解。最终通过一系列局部最优解来达到全局最优解，所以说能使用贪心算法正确求解的问题具有最优子结构。

贪心算法往往得不到整体最优解，选择贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。

### 适用情况

贪心策略适用的前提是：局部最优能导致产生全局最优解。可适用情况很少。

---

## 回溯法

### 基本概念

回溯法实际上是一个类似枚举的搜索尝试过程，在搜索中寻找可能解，当发现已不满足求解条件时，就回溯返回，尝试别的路径。回溯法是选优搜索法，按选优条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择达不到目标，就退回一步重新选择，这种走不通就回退技术为回溯法，满足回溯条件的某个状态点称为回溯点。

### 基本思想

在包含问题所有解的解空间树中按照深度优先搜索策略，从根节点出发深度搜索解空间树，当搜索到某一节电时，先判断以该节点为根节点的子树中是否包含问题的解，如果包含则继续探索下去，否则逐层向根节点回溯。

若要用回溯法求解所有的解，要回溯到根且根节点所有可行的子树都要已被搜索遍才结束。

若要求任一解，搜索到一个解即可结束。

### 回溯法一般步骤

1. 针对问题，确定问题解空间

2. 确定节点扩展搜索规则

3. 以深度优先方式搜索解空间，在搜索过程中用剪枝函数避免无效搜索


---

## 分支限界法

### 基本概念

分支限界法是用于求解组合优化问题的排除非解的搜索算法。类似于回溯法，也是一种在问题的解空间树上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

常见的分支限界法为广度优先分支限界法和优先队列式分支限界法，最主要的区别在于选择拓展节点时是按一般队列顺序选择队列的首元素还是通过优先队列选择具有最优结果的元素。

### 分支限界法一般过程

分支限界法以广度优先的方式搜索解空间树。

分支限界发法搜索策略：在拓展节点处，先生成其所有儿子节点（分支），然后再从当前的活节点表中选择下一个扩展节点。为了有效地选择下一扩展节点，以加速搜索进程，在每一个活节点处，计算一个函数值，并根据这些已计算出的函数值，在当前活节点表中选择一个最有利的节点作为扩展节点，使搜索朝着解空间树上最优解推进。

分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。


---

## NP完全性理论

### 基本概念

1. 以多项式为时间复杂度的算法称为多项式时间算法，有多项式时间算法的问题称作易解的，不存在多项式时间算法问题称作难解的。

2. 所有多项式时间可解的判定问题组成的问题类称作P类问题（易解问题）。

3. 存在判定问题，若给定某问题结果I，存在算法A可在多项式时间内对结果进行验证，则称此判定问题是可验证的，A是其多项式时间验证算法。所有有多项式时间可验证的判定问题组成的问题类称为NP（非确定型多项式）问题。

4. P属于NP。

5. 如果存在某个问题的难度不低于NP问题中任何问题，则这样的问题称为NP难（NP-Hard）问题。

6. 如果某个问题既属于NP问题又是NP难问题，则这个问题是NP（NPC）完全的。

7. 证明P = NP的充分必要条件是NP完全问题属于P问题。

### 通俗理解　

就是在所有的问题中，如果在多项式时间内可以得到结果的问题称为P问题，但是有些问题尚不能被证明是否存在多项式时间内时间算法，不过很多这类问题虽然求解具体的答案比较复杂，但是如果给定一个确定的结果，还是很容易在多项式时间内验证是否满足此问题，这种问题称为NP问题。

在所有NP问题中，我们假设存在最困难的问题，这个问题的不会比任何NP问题简单，则这个问题称为NPC问题。如果我们证明了最难的NP问题（即NPC问题）都能够在多项式时间内求解，则一定可以得到P = NP。所以目前对于P是否等于NP的研究主要取决于NPC问题和P问题的关系。

---


## 近似算法
